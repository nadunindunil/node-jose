/** Declaration file generated by dts-gen */

export type KeyUse = 'sig' | 'enc' | 'desc';

export interface JWEEncryptor {
  update(input: any): this;
  final(): Promise<string>;
}

export interface RawKey {
  alg: string;
  kty: string;
  use: KeyUse;

  // e and n make up the public key
  e: string;
  n: string;
}

export interface KeyStoreGetFilter {
  kty?: string;
  use?: KeyUse;
  alg: string;
}

export interface KeyStoreGetOptions extends KeyStoreGetFilter {
  kid: string;
}

export interface JWKKeyStore {
  toJSON(exportPrivateKeys?: boolean): object;
  get(kid: string, filter?: KeyStoreGetFilter): RawKey;
  get(options: KeyStoreGetOptions): RawKey;
  all(options: Partial<KeyStoreGetOptions>): RawKey[];
  add(key: RawKey): Promise<JWKKey>;
  /**
   * @param key
   *  String serialization of a JSON JWK/(base64-encoded) PEM/(binary-encoded) DER
   *  Buffer of a JSON JWK/(base64-encoded) PEM/(binary-encoded) DER
   * @param form
   * is either a:
   * - "json" for a JSON stringified JWK
   * - "private" for a DER encoded 'raw' private key
   * - "pkcs8" for a DER encoded (unencrypted!) PKCS8 private key
   * - "public" for a DER encoded SPKI public key (alternate to 'spki')
   * - "spki" for a DER encoded SPKI public key
   * - "pkix" for a DER encoded PKIX X.509 certificate
   * - "x509" for a DER encoded PKIX X.509 certificate
   * - "pem" for a PEM encoded of PKCS8 / SPKI / PKIX
   */
  add(
    key: string | Buffer,
    form: 'json' | 'private' | 'pkcs8' | 'public' | 'spki' | 'pkix' | 'x509' | 'pem'
  ): Promise<JWKKey>;
  remove(key: JWKKey);
}

export interface JWKKey {
  /**
   * Defaults to false
   */
  toPEM(isPrivate?: boolean);
  keystore: JWKKeyStore;
  length: number;
  kty: string;
  kid: string;
  use: KeyUse;
  alg: string;
}

export function canYouSee(ks: JWKKey | JWKKeyStore, opts: any): any;

export function parse(input: string): any;

export namespace JWA {
  function decrypt(alg: any, key: any, cdata: any, props: any): any;

  function derive(alg: any, key: any, props: any): any;

  function digest(alg: any, data: any, props: any): any;

  function encrypt(alg: any, key: any, pdata: any, props: any): any;

  function sign(alg: any, key: any, pdata: any, props: any): any;

  function verify(alg: any, key: any, pdata: any, mac: any, props: any): any;

}

export interface JWEEncryptor {
  update(input: any): this;
  final(): Promise<string>;
}

export interface JWEDecryptor {
  decrypt(input: string): Promise<JWEDecryptResult>;
}

export interface JWEDecryptResult {
  /**
   * an array of the member names from the "protected" member
   */
  protected: string[];
  /**
   * the decrypted content (alternate)
   */
  plaintext: Buffer;
}

export namespace JWE {
  function createEncrypt(key: JWKKey): JWEEncryptor;
  function createEncrypt(keys: JWKKey[]): JWEEncryptor;
  function createEncrypt(
    key: JWKKey,
    options: {
      format?: 'compact' | 'flattened';
      zip?: boolean;
    }
  ): JWEEncryptor;

  function createDecrypt(key: JWKKey): JWEDecryptor;
}

export namespace JWK {
  const MODE_DECRYPT: string;

  const MODE_ENCRYPT: string;

  const MODE_SIGN: string;

  const MODE_UNWRAP: string;

  const MODE_VERIFY: string;

  const MODE_WRAP: string;
  // extra missing

  function asKey(rawKey: RawKey): Promise<JWKKey>;

  function asKey(
    key: string | Buffer,
    form: 'json' | 'private' | 'pkcs8' | 'public' | 'spki' | 'pkix' | 'x509' | 'pem'
  ): Promise<JWKKey>;

  function asKeyStore(ks: any): Promise<JWKKeyStore>;

  function createKey(kty: any, size: any, props: any): JWKKey;

  function createKeyStore(): JWKKeyStore;

  function isKey(obj: any): nput is JWKKey;

  function isKeyStore(obj: any): input is JWKKeyStore;
}

export interface BaseResult {
  /**
   * the combined 'protected' and 'unprotected' header members
   */
  header: any;
  /**
   * the signed content
   */
  payload: Buffer;
  /**
   * The key used to verify the signature
   */
  key: JWKKey;
}

export interface VerificationResult extends BaseResult {
  /**
   * the verified signature
   */
  signature: Buffer;
}

export interface JWSVerifier {
  verify(input: string): Promise<VerificationResult>;
}

export namespace JWS {
  function createSign(opts: any, signs: any, ...args: any[]): any;

  /**
   * Using a keystore.
   */
  function createVerify(keyStore: JWKKeyStore): JWSVerifier;

  /**
   * To verify using an implied Key
   */
  function createVerify(keyStore: JWKKey): JWSVerifier;

  /**
   * To verify using a key embedded in the JWS
   */
  function createVerify(): JWSVerifier;

  //   function createVerify(ks: any, opts: any): any;
}

export namespace parse {
  const prototype: {};

  function compact(input: any): any;

  function json(input: any): any;
}

export namespace util {
  function asBuffer(input: any, encoding: any): any;

  function randomBytes(len: any): any;

  namespace asBuffer {
    const prototype: {};
  }

  namespace base64url {
    function decode(base64url: any): any;

    function encode(buffer: any, encoding: any): any;

    namespace decode {
      const prototype: {};
    }

    namespace encode {
      const prototype: {};
    }
  }

  namespace randomBytes {
    const prototype: {};
  }

  namespace utf8 {
    function decode(input: any): any;

    function encode(input: any): any;

    namespace decode {
      const prototype: {};
    }

    namespace encode {
      const prototype: {};
    }
  }
}
